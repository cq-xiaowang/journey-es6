<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>流式图片加载（按响应顺序填充网格）</title>
  <style>
    .img-container {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      padding: 20px;
      width: 100%;
    }

    .img-slot {
      width: 200px;
      height: 150px;
      border: 1px solid #eee;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f9f9f9;
      position: relative;
      overflow: hidden;
    }

    .img-slot img {
      max-width: 100%;
      max-height: 100%;
      object-fit: cover;
    }

    .retry-count {
      position: absolute;
      top: 5px;
      right: 5px;
      font-size: 12px;
      color: #888;
    }

    .loading, .error {
      font-size: 12px;
      text-align: center;
      color: #666;
    }

    .error {
      color: #e74c3c;
    }
  </style>
</head>
<body>
  <div class="img-container" id="container"></div>

  <script>
    // ====== 配置 ======
    const MAX_RETRY = 3;
    const RETRY_DELAY = 1000;
    const TIMEOUT = 5000;

    /**
     * 带超时的 fetch
     */
    function fetchWithTimeout(url, timeout = TIMEOUT) {
      return Promise.race([
        fetch(url),
        new Promise((_, reject) =>
          setTimeout(() => reject(new Error('Request timeout')), timeout)
        )
      ]);
    }

    /**
     * 创建一个空的网格槽（slot）
     */
    function createSlot() {
      const slot = document.createElement('div');
      slot.className = 'img-slot';
      slot.innerHTML = '<div class="loading">等待图片...</div>';
      return slot;
    }

    // ====== 全局状态 ======
    const TOTAL_IMAGES = 50; // 可改为 100，但建议先测试小数量
    const container = document.getElementById('container');

    // 预创建所有槽位（固定布局，无空洞）
    const slots = [];
    for (let i = 0; i < TOTAL_IMAGES; i++) {
      const slot = createSlot();
      container.appendChild(slot);
      slots.push(slot);
    }

    let nextSlotIndex = 0; // 下一个可用槽位索引
    let completedCount = 0; // 已成功/失败处理的数量

    /**
     * 安全地将图片填入下一个空槽
     */
    function fillNextSlot(blobUrl, url) {
      if (nextSlotIndex >= TOTAL_IMAGES) return; // 安全边界

      const slot = slots[nextSlotIndex];
      nextSlotIndex++;

      const img = document.createElement('img');
      img.src = blobUrl;
      slot.replaceChildren(img);

      // 可选：释放内存
      img.onload = () => URL.revokeObjectURL(blobUrl);
    }

    /**
     * 处理加载失败（可选：也占位，或跳过）
     */
    function handleFailure(url, error) {
      console.warn('跳过失败图片:', url, error.message);
      // 如果你想让失败图片也占位，可以在这里 fillNextSlot 一个占位图
    }

    /**
     * 加载单张图片（独立重试逻辑）
     */
    async function loadImage(url) {
      let attempt = 0;

      while (attempt <= MAX_RETRY) {
        attempt++;
        try {
          const response = await fetchWithTimeout(url);
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const blob = await response.blob();
          const blobUrl = URL.createObjectURL(blob);

          // 成功：填入下一个槽
          fillNextSlot(blobUrl, url);
          completedCount++;
          return;
        } catch (error) {
          if (attempt > MAX_RETRY) {
            handleFailure(url, error);
            completedCount++;
            return;
          }
          await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));
        }
      }
    }

    // ====== 启动并行请求 ======
    const imageUrls = [];
    for (let i = 1; i <= TOTAL_IMAGES; i++) {
      imageUrls.push(`https://picsum.photos/200/150?random=${i}&t=${Date.now()}`);
    }

    // 所有请求并行发起！
    imageUrls.forEach(url => {
      loadImage(url).catch(err => {
        console.error('未捕获错误:', err);
        completedCount++;
      });
    });

    // 可选：监控完成状态
    const checkAllDone = setInterval(() => {
      if (completedCount >= TOTAL_IMAGES) {
        clearInterval(checkAllDone);
        console.log('✅ 所有图片处理完毕');
      }
    }, 500);
  </script>
</body>
</html>